### 阅读重点

* eureka-client 初始化
* eureka-server 启动
* 注册表关系，主要类 InstanceRegistry
* 应用实例 -- 注册 :Eureka-Client 向 Eureka-Server 发起注册
* 应用实例 -- 续租 ：eureka-Client 向 Eureka-Server 发起注册应用实例成功后获得租约 ( Lease )
* 应用实例 -- 下线 ： Eureka-Client 向 Eureka-Server 发起下线应用实例
* 应用实例 -- 自我保护机制
* 应用实例 -- 过期 ：应用实例可能异常崩溃，又或者是网络异常等原因，导致下线请求无法被成功提交。
* 应用实例 -- 全量获取
* 应用实例 -- 增量获取
* 应用实例 -- 覆盖状态
* 应用实例 -- 读写锁
* 应用实例 -- 任务批处理
* 应用实例 -- 网络通信
* 应用实例 -- 集群同步
* 应用实例 -- 令牌桶算法RateLimiter
* 应用实例 -- 缓存


### 要点
 
 * 默认配置下，Eureka-Client 启动时，首先执行一次全量获取进行本地缓存注册信息，而后每 30 秒增量获取刷新本地缓存( 非“正常”情况下会是全量获取 )。
 * Eureka-Client 在初始化过程中，创建获取注册信息线程，固定间隔向 Eureka-Server 发起获取注册信息( fetch )，刷新本地注册信息缓存
 * 全量获取的条件：
 
 
      配置 eureka.disableDelta = true ，禁用增量获取注册信息。默认值：false 。
      只获得一个 vipAddress 对应的应用实例们的注册信息
      方法参数 forceFullRegistryFetch 强制全量获取注册信息
      本地缓存为空
      调用 #getAndStoreFullRegistry() 方法，全量获取注册信息，并设置到本地缓存。
      
* 缓存过期策略


    应用实例注册、下线、过期时，只只只过期 readWriteCacheMap 。
    readWriteCacheMap 写入一段时间( 可配置 )后自动过期。
    定时任务对比 readWriteCacheMap 和 readOnlyCacheMap 的缓存值，若不一致，以前者为主。通过这样的方式，实现了 readOnlyCacheMap 的定时过期。
    
    
* 应用集合一致性哈希码


     增量获取注册的应用集合( Applications ) 时，Eureka-Client 会获取到：
     
     Eureka-Server 近期变化( 注册、下线 )的应用集合
     Eureka-Server 应用集合一致性哈希码
     Eureka-Client 将变化的应用集合和本地缓存的应用集合进行合并后进行计算本地的应用集合一致性哈希码。若两个哈希码相等，意味着增量获取成功；若不相等，意味着增量获取失败，Eureka-Client 重新和 Eureka-Server 全量获取应用集合。
     
* 令牌桶算法


    令牌桶算法的限流的特点：让流量平稳，而不是瞬间流量。1000 QPS 相对平均的分摊在这一秒内，而不是第 1 ms 999 请求，后面 999 ms 0 请求。
    获取令牌时才计算，多次令牌填充可以合并成一次，减少冗余和无效的计算。
    
* 集群


     Eureka-Server 集群不区分主从节点或者 Primary & Secondary 节点，所有节点相同角色( 也就是没有角色 )，完全对等。
     Eureka-Client 可以向任意 Eureka-Client 发起任意读写操作，Eureka-Server 将操作复制到另外的 Eureka-Server 以达到最终一致性。注意，Eureka-Server 是选择了 AP 的组件
   